# Lagom: Read-Side support

This page is specifically about Lagom's support for Couchbase read-sides.  
Before reading this, you should familiarize yourself with Lagom's general 
@scala[[read-side support](https://www.lagomframework.com/documentation/1.4.x/scala/ReadSide.html)]
@java[[read-side support](https://www.lagomframework.com/documentation/1.4.x/java/ReadSide.html)].

## Query the Read-Side Database

Let us first look at how a service implementation can retrieve data from Couchbase.

Scala
:  @@snip [imports](../../test/scala/docs/home/persistence/CouchbaseReadSideQuery.scala) { #imports #service-impl }

Java
:  @@snip [imports](../../test/java/jdocs/home/persistence/CouchbaseReadSideQuery.java) { #imports #service-impl }


The `CouchbaseSession` is injected in the constructor. `CouchbaseSession` provides several methods in different 
flavors for executing queries. The one used in the above example returns a document. There are also methods for streaming 
a result set, which can be useful when the result set is big.

All methods in `CouchbaseSession` are non-blocking and they return a @scala[Future]@java[CompletionStage] or a `Source`.

## Update the Read-Side

We need to transform the events generated by the Persistent Entities into a Couchbase documents that can be queried as 
illustrated in the previous section. 
For that we will implement a `ReadSideProcessor` with assistance from the `CouchbaseReadSide` support component. 
It will consume events produced by persistent entities and update documents in Couchbase that are optimized for queries.

This is how a `ReadSideProcessor` class looks like before filling in the implementation details:

Scala
:  @@snip [imports](../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #imports #initial }

Java
:  @@snip [imports](../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #imports #initial }


You can see that we have injected the Couchbase read-side support, these will be needed later.

You should already have implemented tagging for your events as described in the 
@java[[Read-Side documentation](https://www.lagomframework.com/documentation/current/java/ReadSide.html#Event-tags)]
@scala[[Read-Side documentation](https://www.lagomframework.com/documentation/current/scala/ReadSide.html#Event-tags)], 
so first we'll implement the `aggregateTags` method in our read-side processor stub, like so:

Scala
:  @@snip [tag](../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #tag }

Java
:  @@snip [tag](../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #tag }


### Building the read-side handler

The other method on the `ReadSideProcessor` is `buildHandler`. This is responsible for creating the `ReadSideHandler` 
that will handle events. It also gives the opportunity to run two callbacks, one is a global prepare callback, 
the other is a regular prepare callback.

`CouchbaseReadSide` has a `builder` method for creating a builder for these handlers, this builder will create a handler 
that will automatically handle readside offsets for you. It can be created like so:

Scala
:  @@snip [create-builder](../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #create-builder }

Java
:  @@snip [create-builder](../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #create-builder }

The argument passed to this method is the ID of the event processor that Lagom will use when it persists offsets to its 
offset store. The offsets stored in a Couchbase documents, which will be created and updated for you. 

### Global prepare

The global prepare callback runs at least once across the whole cluster. It is intended for doing things like 
creating documents and preparing any data that needs to be available before read side processing starts.
Read side processors may be sharded across many nodes, and so tasks like creating documents should usually only be done 
from one node.

The global prepare callback is run from an Akka cluster singleton. It may be run multiple times - every time a new node 
becomes the new singleton, the callback will be run. Consequently, the task must be idempotent. If it fails, it will be 
run again using an exponential backoff, and the read side processing of the whole cluster will not start until it has 
run successfully.

Of course, setting a global prepare callback is completely optional.

Below is an example method that we've implemented to create a document:

Scala
:  @@snip [create-document](../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #create-document }

Java
:  @@snip [create-document](../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #create-document }


It can then be registered as the global prepare callback in the `buildHandler` method:

Scala
:  @@snip [register-global-prepare](../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #register-global-prepare }

Java
:  @@snip [register-global-prepare](../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #register-global-prepare }


### Prepare

In addition to the global prepare callback, there is also a prepare callback. This will be executed once per shard, 
when the read side processor starts up.

Again this callback is optional.

Scala
:  @@snip [prepare-statements](../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #prepare-statements }

Java
:  @@snip [prepare-statements](../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #prepare-statements }


And then to register them:

Scala
:  @@snip [register-prepare](../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #register-prepare }

Java
:  @@snip [register-prepare](../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #register-prepare }


### Registering your read-side processor

Once you've created your read-side processor, you need to register it with Lagom. This is done using the `ReadSide` component:

Scala
:  @@snip [register-event-processor](../../test/scala/docs/home/persistence/CouchbaseReadSideQuery.scala) { #register-event-processor }

Java
:  @@snip [register-event-processor](../../test/java/jdocs/home/persistence/CouchbaseReadSideQuery.java) { #register-event-processor }



### Event handlers

The event handlers take an event, and execute updates.

@@@ warning { title='Caveat' }
Couchbase read-side processors have at-least-once semantics and should be idempotent because it isn't possible 
in Couchbase to atomically execute the offset update and the other statements.
@@@

Here's an example callback for handling the `GreetingMessageChanged` event:

Scala
:  @@snip(../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #greeting-message-changed }

Java
:  @@snip(../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #greeting-message-changed }




This can then be registered with the builder using `setEventHandler`:

Scala
:  @@snip [set-event-handler](../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #set-event-handler }

Java
:  @@snip [set-event-handler](../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #set-event-handler }


Once you have finished registering all your event handlers, you can invoke the `build` method and return the built handler:

Scala
:  @@snip [build](../../test/scala/docs/home/persistence/CouchbaseReadSideProcessor.scala) { #build }

Java
:  @@snip [build](../../test/java/jdocs/home/persistence/CouchbaseHelloEventProcessor.java) { #build }


## Underlying implementation

The `CouchbaseSession` is using the Couchbase Java SDK, which can be accessed directly using the `CouchbaseSession.underlying()`
method. However the native API of the client is based on RxJava and does not provide @scala[Future]@java[CompletionStage] and 
Akka Stream APIs. 

Each `ReadSideProcessor` instance is executed by an [Actor](https://doc.akka.io/docs/akka/2.5/actors.html?language=java) 
that is managed by [Akka Cluster Sharding](https://doc.akka.io/docs/akka/2.5/cluster-sharding.html?language=java). 
The processor consumes a stream of persistent events delivered by the `eventsByTag` 
[Persistence Query](https://doc.akka.io/docs/akka/2.5/persistence-query.html?language=java) implemented by 
[akka-persistence-couchbase](https://github.com/akka/akka-persistence-couchbase). The tag corresponds to the `tag` 
defined by the `AggregateEventTag` and the number of tags will determine how many read-side processors will be running across all nodes of your cluster. 

